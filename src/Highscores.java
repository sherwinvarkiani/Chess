
import java.io.File;
import javax.swing.JOptionPane;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXParseException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *  File Name:  Highscores.java
 *  Programmer: Sherwin Varkiani
 *  Date:       6/18/2017
 *  Description:This file is the high score system. It  allows users to search for a player and sort the high scores in ascending and descending order
 */
public class Highscores extends javax.swing.JFrame {

    int[] scoresList;
    String[] highscoreList;

    public Highscores() {
        initComponents();

        try {
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            File inputFile = new File("highscores.xml"); //makes hello.xml the input file
            Document doc = db.parse(inputFile);
            doc.getDocumentElement().normalize();
            NodeList listOfScores = doc.getElementsByTagName("highscore"); //gets a list of how many courses there are
            highscoreList = new String[listOfScores.getLength()];
            scoresList = new int[listOfScores.getLength()];
            double convertIn = 0;
            for (int s = 0; s < listOfScores.getLength(); s++) { //loops through every course
                Node scoreNode = listOfScores.item(s);
                if (scoreNode.getNodeType() == Node.ELEMENT_NODE) {
                    Element firstScoreElement = (Element) scoreNode;
                    NodeList scoreList = firstScoreElement.getElementsByTagName("score"); //gets the element with the name score
                    Element scoreElement = (Element) scoreList.item(0);
                    NodeList textScoreList = scoreElement.getChildNodes(); //adds the value to a nodelist which will be stored in the array
                    highscoreList[s] = ((Node) textScoreList.item(0)).getNodeValue().trim();
                    convertIn = Double.parseDouble(((Node) textScoreList.item(0)).getNodeValue().trim());
                    scoresList[s] = (int) convertIn;
                    NodeList nameList = firstScoreElement.getElementsByTagName("name"); //gets the element with the name name
                    Element nameElement = (Element) nameList.item(0);
                    NodeList textNameList = nameElement.getChildNodes(); //adds the value to a nodelist which will be stored in the array
                    highscoreList[s] += "-" + ((Node) textNameList.item(0)).getNodeValue().trim();
                    NodeList timeList = firstScoreElement.getElementsByTagName("time"); //gets the element with the name name
                    Element timeElement = (Element) timeList.item(0);
                    NodeList textTimeList = timeElement.getChildNodes(); //adds the value to a nodelist which will be stored in the array
                    highscoreList[s] += " (" + ((Node) textTimeList.item(0)).getNodeValue().trim() + ")\n";

                }
            }

            String output = "";
            for (int i = 0; i < highscoreList.length; i++) { //loops through the array and adds it to an output
                output += highscoreList[i];

            }
            HighScoresOutput.setText(output); //outputs the scores
        } catch (SAXParseException err) { //catches any errors
            System.out.println("Error Occurred"); //outputs a message
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        TitleLabel = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        HighScoresOutput = new javax.swing.JTextArea();
        SearchInput = new javax.swing.JTextField();
        SearchLabel = new javax.swing.JLabel();
        AscendingSortButton = new javax.swing.JButton();
        DescendingSortButton = new javax.swing.JButton();
        SortLabel = new javax.swing.JLabel();
        SearchButton = new javax.swing.JButton();
        ExitButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        TitleLabel.setFont(new java.awt.Font("Tahoma", 0, 36)); // NOI18N
        TitleLabel.setText("High Scores");

        HighScoresOutput.setColumns(20);
        HighScoresOutput.setRows(5);
        jScrollPane1.setViewportView(HighScoresOutput);

        SearchLabel.setText("Search for:");

        AscendingSortButton.setText("Ascending Order");
        AscendingSortButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AscendingSortButtonActionPerformed(evt);
            }
        });

        DescendingSortButton.setText("Descending Order");
        DescendingSortButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                DescendingSortButtonActionPerformed(evt);
            }
        });

        SortLabel.setText("Sort by:");

        SearchButton.setText("Search");
        SearchButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SearchButtonActionPerformed(evt);
            }
        });

        ExitButton.setText("Exit");
        ExitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExitButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(TitleLabel)
                .addGap(118, 118, 118))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(40, 40, 40)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(172, 172, 172)
                                .addComponent(SearchButton))
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(AscendingSortButton)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(DescendingSortButton))
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(SortLabel)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(SearchLabel)
                                            .addGap(18, 18, 18)
                                            .addComponent(SearchInput))
                                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 352, javax.swing.GroupLayout.PREFERRED_SIZE))))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(185, 185, 185)
                        .addComponent(ExitButton)))
                .addContainerGap(42, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(23, 23, 23)
                .addComponent(TitleLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 493, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(39, 39, 39)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(SearchInput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(SearchLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(SearchButton)
                .addGap(18, 18, 18)
                .addComponent(SortLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(DescendingSortButton)
                    .addComponent(AscendingSortButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ExitButton)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /*
        Pre-Condition: This function activates when the ascending order button is clicked
        Post-Condition: Sorts the high scores through insertion sort in descending order
    */
    private void AscendingSortButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AscendingSortButtonActionPerformed
        highscoreList = insertionSort(scoresList, highscoreList); //calls the insertion sort function
        String output = "";
        for (int i = 0; i < highscoreList.length; i++) { //loops through the array and adds it to an output
            output += highscoreList[i];
        }
        HighScoresOutput.setText(output); //outputs the sorted array

    }//GEN-LAST:event_AscendingSortButtonActionPerformed

    /*
        Pre-Condition: This function activates when the descending order button is clicked
        Post-Condition: Sorts the high scores through insertion sort in descending order
    */
    private void DescendingSortButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_DescendingSortButtonActionPerformed
        highscoreList = insertionSort(scoresList, highscoreList); //calls the insertion sort function
        String output = "";
        for (int i = highscoreList.length - 1; i >= 0; i--) { //loops through the array and adds it to an output
            output += highscoreList[i];
        }
        HighScoresOutput.setText(output); //outputs the sorted array
    }//GEN-LAST:event_DescendingSortButtonActionPerformed

    /*
        Pre-Condition: This function activates when the sort button is clicked
        Post-Condition: Searches through the array using linear search and outputs the player, their score, ranking and time they got the score
    */
    private void SearchButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SearchButtonActionPerformed
        String input = SearchInput.getText(); //gets the name from the user
        String output = linearSearch(highscoreList, input); //calls upon the linearsearch function
        if (output == "no") { //if there is no player with that name it outputs a message
            JOptionPane.showMessageDialog(null, "There is no player with that name");
        } else { //if it finds the player
            highscoreList = insertionSort(scoresList, highscoreList); //it sorts the list so that it can find what place the player is in
            for (int i = highscoreList.length - 1; i >= 0; i--) { //loops through the array in descending order
                if (output.equals(highscoreList[i]) == true) { //if the name matches it outputs a message
                    JOptionPane.showMessageDialog(null, "The following player was found: " + input + "\n" + (highscoreList.length - i) + ") " + output);
                }
            }

        }

    }//GEN-LAST:event_SearchButtonActionPerformed

    /*
        Pre-Condition: Activates when the user clicks the exit button
        Post-Condition: Switches between jframes
    */
    private void ExitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExitButtonActionPerformed
        this.setVisible(false);
        new Chess().setVisible(true); //switches between jframes
    }//GEN-LAST:event_ExitButtonActionPerformed

    /*
        Pre-Condition: Activates when the sort button calls the function. Takes the array of numbers and scores
        Post-Condition: Returns the sorted array that is sorted through insertion sort
     */
    public String[] insertionSort(int[] numberList, String[] highscoreList) {
        String temporary = "";
        for (int i = 1; i < numberList.length; i++) { //loops through the array
            int temp = numberList[i]; //insertion sort sorts through numbers so as it sorts the number array I also sort the highscore array
            temporary = highscoreList[i];
            int j = i - 1;
            while (j >= 0 && numberList[j] > temp) {
                numberList[j + 1] = numberList[j]; //swaps the values
                highscoreList[j + 1] = highscoreList[j];
                j = j - 1;
            }
            numberList[j + 1] = temp;
            highscoreList[j + 1] = temporary;
        }
        return highscoreList;
    }

    /*
        Pre-Condition: Activates when the button calls the function. Takes the scores array and the score number
        Post-Condition: Returns the name of the book if it matches the id
                        If not it returns the word no
     */
    public static String linearSearch(String[] highscoreList, String referenceName) {
        String temp = "";
        boolean isName = false;
        boolean nameEnd = false;

        for (int i = 0; i < highscoreList.length; i++) { //loops through the array
            for (int j = 0; j < highscoreList[i].length() - 1; j++) { //loops through the string
                if ((highscoreList[i].charAt(j) == '-' || isName == true) && nameEnd == false) { //if the character - has passed
                    if (isName == false) {
                        isName = true;
                        j++; //increases the counter
                    }
                    if (highscoreList[i].charAt(j+2) == '(') { //if it reaches the time then it stops tracking the name
                        nameEnd = true;
                    }
                    
                    temp += highscoreList[i].charAt(j); //gets the name
                }
            }
            isName = false;
            nameEnd = false;
            if (temp.equals(referenceName) == true) { //if the name matches the reference name it returns the name
                return highscoreList[i];
            }
            temp = "";
        }
        return "no"; //if there is no value that matches it will return no

    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Highscores.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Highscores.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Highscores.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Highscores.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Highscores().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton AscendingSortButton;
    private javax.swing.JButton DescendingSortButton;
    private javax.swing.JButton ExitButton;
    private javax.swing.JTextArea HighScoresOutput;
    private javax.swing.JButton SearchButton;
    private javax.swing.JTextField SearchInput;
    private javax.swing.JLabel SearchLabel;
    private javax.swing.JLabel SortLabel;
    private javax.swing.JLabel TitleLabel;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
}
